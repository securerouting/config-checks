#!/usr/bin/env python
#
#  Copyright (c) 2015, Parsons, Inc
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#
#  *  Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#  *  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  *  Neither the name of Parsons, Inc nor the names of its contributors may
#     be used to endorse or promote products derived from this software
#     without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
#  IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
#  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
#  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#
# rpkichk	This script validates the contents of an rpki.conf file.  It
#		performs several levels of checks.  Currently, these are basic
#		checks, cross-checks, and recommended-value checks.  The basic
#		checks ensure that the config values have a rudimentary level
#		of sanity; for example, directories are directories, booleans
#		are true/false values.  Cross-checks ensure that values in one
#		section that are related to values in another section
#		correspond.  The recommended-value checks ensure that some
#		of the fields have the values recommended by the rpki.net
#		developers.
#
#
#	This is the call tree for the routines (mostly) defined in this module.
#	This tree might make it easier to update rpkichk in the future.
#
#		main()
#			getopts()
#
#			readconf()		[in confvalidation.py]
#
#			check_rpki()
#				basic_checks()
#					basic_autoconf()
#					basic_irdbd()
#					basic_myrpki()
#					basic_pubd()
#					basic_rootd()
#					basic_rpkid()
#					basic_web_portal()
#
#				cross_checks()
#					cross_check_sect()
#
#				recval_checks()
#					recval_chk()
#
#			results()
#				basic_results()
#					giveproblems()
#					givesummary()
#					givetable()
#					giveparseerrs()
#
#				crosscheck_results()
#					giveproblems()
#					givesummary()
#					givetable()
#					giveparseerrs()
#
#	It is highly likely that some of these routines can be collapsed
#	into a smaller number of more general routines.  For now, though,
#	this is the way it is.
#
#
# Revision History
#	1.0	Initial revision.				150317
#	1.1	Cross checks, section exclusion, and result	150414
#		specific output were added.
#	1.2	Fixed problem reporting.			150427
#	1.3	Added recommended-value checks.			150509
#
#	Copyright 2015 PARSONS, Inc.  All rights reserved.
#	Written by Wayne Morrison, 150317.
#


import os
import sys
import argparse

import rpki.config
import rpki.exceptions

from confvalidation import *

#
# Version information.
#
NAME = "rpkichk"
VERS = NAME + " version: 1.3"

#------------------------------------------------------------------------
# Options handled:
#		-config conffile	specify config file to read
#
#		-list			list configuration-section information
#		-names			list configuration-section names
#		-untranslate		list untranslated values
#		-section section-name	specify section to examine
#
#		-problems		give problems found
#		-summary		give summary of checks
#		-table			show table of results
#
#		-basic			only basic checks
#		-cross			only cross checks
#		-recval			only recommended-value checks
#
#		-noautoconf		don't check the autoconf section
#		-noirdbd		don't check the irdbd section
#		-nomyrpki		don't check the myrpki section
#		-nopubd			don't check the pubd section
#		-norootd		don't check the rootd section
#		-norpkid		don't check the rpkid section
#		-noweb_portal		don't check the web_portal section
#
#		-verbose		turn on verbose output
#		-help			give usage message and exit
#		-manpage		print the manpage and exit
#		-Version		give command version info and exit
#

# Default configuration file.
DEFCONF = '/etc/rpki.conf'

conffile = DEFCONF				# Configuration file.
sector = None					# Section to examine.

dobasic  = 0					# Basic checks only.
docross  = 0					# Cross checks only.
dorecval = 0					# Recommended-value checks only.

showsummary = 0					# Summarize checks only.
showtable   = 0					# Show table of results.
showprobs   = 0					# Show problems found.

verbose = 0					# Verbose flag.

#
# This dictionary holds flags for command-line options to turn off checking for
# various sections of the rpki.conf file.  The default is to check everything.
#
skipsect = {}

#------------------------------------------------------------------------
# Globbies.
#

CHECKS_BASIC  = 0;		# Flag for basic checks.
CHECKS_CROSS  = 1;		# Flag for cross checks.
CHECKS_RECVAL = 2;		# Flag for recommended-value checks.

cfg = None			# Data from configuration file.

badsect = {}			# Invalid config section names.
errors = {}			# Error counts by config sections.
parseerrs = {}			# Parsing errors.
unchecked = {}			# Unchecked-field counts by sections.
valids = {}			# Valid lines by config sections.

cck_errors = {}			# Cross-check error counts by config sections.
cck_unchecked = {}		# Cross-check unchecked-field counts by sects.
cck_valids = {}			# Cross-check valid lines by config sections.

rv_errors = {}			# Recval-check error counts by config sections.
rv_unchecked = {}		# Recval-check unchecked-field counts by sects.
rv_valids = {}			# Recval-check valid lines by config sections.

problems = {}			# Details of basic problems in a section.
cck_problems = {}		# Details of cross-check problems in a section.
rv_problems = {}		# Details of recval-check problems in a section.


#------------------------------------------------------------------------
# Routine:	main()
#
# Purpose:	Do everything.
#
def main():
	global cfg			# Configuration file contents.

	#
	# Parse our command line.
	#
	getopts()

	#
	# Read the configuration file.
	#
	cfg = readconf(conffile)

	#
	# Possibly give section info from config file.
	#
	if(getlistflag()):
		lister(conffile,cfg,sector)
		exit(0)

	#
	# Check the rpki.conf file.
	#
	check_rpki()

	#
	# Tell the user what they want to know.
	#
	results()

	sys.exit(0)


#------------------------------------------------------------------------
# Routine:	getopts()
#
# Purpose:	Parse the command line for options, most importantly to
#		find a potential non-standard config file.
#
def getopts():
	global conffile				# Configuration file.
	global sector				# Section-name to work with.
	global skipsect				# Skip-sections flags hash.
	global showprobs			# Show problems found.
	global showsummary			# Summarize checks only.
	global showtable			# Show results table.
	global verbose				# Give verbose output.
	global dobasic				# Basic checks only.
	global docross				# Cross checks only.
	global dorecval				# Recommended-value checks only.
	listflag = 0				# Section-listing flag.
	nameflag = 0				# Section-name-listing flag.
	untransflag = 0				# Don't-translate-keyvals flag.
	summary = 0				# Give-summary flag.
	verbose = 0				# Verbose flag.

	#
	# Build our usage string.
	#
	usagestr = usage(0)

	#
	# Build the options parser.
	#
#	ap = argparse.ArgumentParser(usage=usagestr, add_help=False)
	ap = argparse.ArgumentParser()

	#
	# Add the recognized options.
	#
	ap.add_argument('-config', help='path of rpki.conf to check')
	ap.add_argument('-names', action='store_true', help='gives rpki.conf section names and field counts')
	ap.add_argument('-untranslate', action='store_true', help='list values as given and without translation')
	ap.add_argument('-section', help='lists values in the named section; used with -names')

	ap.add_argument('-list', action='store_true', help='list values in rpki.conf')

	ap.add_argument('-basic', action='store_true', help='only run basic checks')
	ap.add_argument('-cross', action='store_true', help='only run cross checks')
	ap.add_argument('-recval', action='store_true', help='only run recommended-value checks')

	ap.add_argument('-problems', action='store_true', help='show problems found')
	ap.add_argument('-summary', action='store_true', help='summarize results')
	ap.add_argument('-table', action='store_true', help='provide results of basic checks in tabular form')

	ap.add_argument('-noautoconf', action='store_true', help='do not check autoconf section')
	ap.add_argument('-noirdbd', action='store_true', help='do not check irdbd section')
	ap.add_argument('-nomyrpki', action='store_true', help='do not check myrpki section')
	ap.add_argument('-nopubd', action='store_true', help='do not check pubd section')
	ap.add_argument('-norootd', action='store_true', help='do not check rootd section')
	ap.add_argument('-norpkid', action='store_true', help='do not check rpkid section')
	ap.add_argument('-noweb_portal', action='store_true', help='do not check web_portal section')

	ap.add_argument('-verbose', action='store_true', help='provide verbose output')
	ap.add_argument('-Version', action='store_true', help='display program version')
	ap.add_argument('-help',    action='store_true', help='display help message')
	ap.add_argument('-manpage', action='store_true', help='display manpage')

	#
	# Now parse the options.
	#
	args = ap.parse_args()

	#
	# Check for some immediate options.
	#
	if(args.Version):		version()
	if(args.help):			usage(1)
	if(args.manpage):		manpage()
	if(args.list):			listflag    = 1
	if(args.names):			nameflag    = 1
	if(args.problems):		showprobs   = 1
	if(args.summary):		showsummary = 1
	if(args.table):			showtable   = 1
	if(args.untranslate):		untransflag = 1
	if(args.verbose):		verbose	    = 1

	skipsect['autoconf']	= args.noautoconf
	skipsect['irdbd']	= args.noirdbd
	skipsect['myrpki']	= args.nomyrpki
	skipsect['pubd']	= args.nopubd
	skipsect['rootd']	= args.norootd
	skipsect['rpkid']	= args.norpkid
	skipsect['web_portal']	= args.noweb_portal

	#
	# -name implies -list.
	#
	if(nameflag):
		listflag = 1

	#
	# Handle the check-specific options.
	#
	if(args.basic):		dobasic  = 1
	if(args.cross):		docross  = 1
	if(args.recval):	dorecval = 1
	if((not dobasic) and (not docross) and (not dorecval)):
		dobasic  = 1
		docross  = 1
		dorecval = 1

	#
	# Set our option values in the confvalidation module.
	#
	setopts(listflag,nameflag,untransflag,verbose)

	#
	# Get the config file from the arguments.  If one wasn't specified
	# with -config, we'll use our (previously set) default.
	#
	if(args.config == None):
		vprint("using default config file - \"%s\"", conffile)
	else:
		conffile = args.config

	#
	# Ensure the selected config file exists and is readable.
	#
	if(existchk(conffile) == 0):
		print "configuration file \"%s\" does not exist" % conffile
		exit(1);
	if(readchk(conffile) == 0):
		print "configuration file \"%s\" is unreadable" % conffile
		exit(1);

	#
	# Get the section name from the arguments.
	#
	if(args.section != None):
		sector = args.section
		vprint("using section - \"%s\"\n", sector)

	#
	# If none of the output-type options were selected, then we'll
	# use them all.
	#
	if((showprobs == 0) and (showsummary == 0) and (showtable == 0)):
		showprobs   = 1
		showsummary = 1
		showtable   = 1


#########################################################################
#
# The following group of handlers validate the entries in the configuration
# file.  Each handler has a handler function and a dictionary mapping the
# section fields to a verification routine.
#

#------------------------------------------------------------------------
# Handler:	basic_autoconf()
#

fields_autoconf = {
			'bindir'	:	chkdir,
			'datarootdir'	:	chkdir,
			'sbindir'	:	chkdir,
			'sysconfdir'	:	chkdir,
		  }

def basic_autoconf(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_autoconf, "called")):
		basic_autoconf.called = 0		# Called flag.
		errors['autoconf'] = 0
		unchecked['autoconf'] = 0
		valids['autoconf'] = 0
	basic_autoconf.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_autoconf.has_key(fkey)):
		if(fields_autoconf[fkey] != None):
			error += fields_autoconf[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "autoconf:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['autoconf']    += error
	unchecked['autoconf'] += unchk
	valids['autoconf']    += (not error)


#------------------------------------------------------------------------
# Handler:	basic_irdbd()
#

fields_irdbd =	{
			'sql-database'	:	chknonnull,
			'sql-password'	:	chksqlpass,
			'sql-username'	:	chksqluser,
			'server-host'	:	chkhostname,
			'server-port'	:	chkhostport,
		}

def basic_irdbd(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_irdbd, "called")):
		basic_irdbd.called = 0
		errors['irdbd'] = 0
		unchecked['irdbd'] = 0
		valids['irdbd'] = 0
	basic_irdbd.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_irdbd.has_key(fkey)):
		if(fields_irdbd[fkey] != None):
			error = fields_irdbd[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "irdbd:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['irdbd']    += error
	unchecked['irdbd'] += unchk
	valids['irdbd']    += (not error)

#------------------------------------------------------------------------
# Handler:	basic_myrpki()
#

fields_myrpki = {
			'bpki_servers_directory'	  :	chkdir,
			'handle'			  :	chkhandle,

			'irdbd_server_host'		  :	chkhostname,
			'irdbd_server_port'		  :	chkhostport,
			'irdbd_sql_database'		  :	chknonnull,
			'irdbd_sql_password'		  :	chksqlpass,
			'irdbd_sql_username'		  :	chksqluser,

			'pubd_server_host'		  :	chkhostname,
			'pubd_server_port'		  :	chkhostport,
			'pubd_sql_database'		  :	chknonnull,
			'pubd_sql_password'		  :	chksqlpass,
			'pubd_sql_username'		  :	chksqluser,

			'publication_base_directory'	  :	chkdir,
			'publication_root_cert_directory' :	chkdir,
			'publication_root_module'	  :	chknonnull,
			'publication_rsync_module'	  :	chknonnull,
			'publication_rsync_server'	  :	chkhostname,

			'rootd_server_host'		  :	chkhostname,
			'rootd_server_port'		  :	chkhostport,

			'rpkid_server_host'		  :	chkhostname,
			'rpkid_server_port'		  :	chkhostport,
			'rpkid_sql_database'		  :	chknonnull,
			'rpkid_sql_password'		  :	chksqlpass,
			'rpkid_sql_username'		  :	chksqluser,

			'run_pubd'			  :	chkbool,
			'run_rootd'			  :	chkbool,
			'run_rpkid'			  :	chkbool,

			'shared_sql_password'		  :	chksqlpass,
			'shared_sql_username'		  :	chksqluser,

			'start_irdbd'			  :	chkbool,
			'start_pubd'			  :	chkbool,
			'start_rootd'			  :	chkbool,
			'start_rpkid'			  :	chkbool
		  }

def basic_myrpki(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_myrpki, "called")):
		basic_myrpki.called = 0
		errors['myrpki'] = 0
		unchecked['myrpki'] = 0
		valids['myrpki'] = 0
	basic_myrpki.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_myrpki.has_key(fkey)):
		if(fields_myrpki[fkey] != None):
			error = fields_myrpki[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "myrpki:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['myrpki']    += error
	unchecked['myrpki'] += unchk
	valids['myrpki']    += (not error)

#------------------------------------------------------------------------
# Handler:	basic_pubd()
#

fields_pubd =	{
			'sql-database'		:	chknonnull,
			'sql-password'		:	chksqlpass,
			'sql-username'		:	chksqluser,
			'server-host'		:	chkhostname,
			'server-port'		:	chkhostport,
			'publication-base'	:	chkdir,
			'bpki-ta'		:	chkfile,
			'pubd-cert'		:	chkfile,
			'pubd-key'		:	chkkeyfile,
			'irbe-cert'		:	chkfile,
		}

def basic_pubd(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_pubd, "called")):
		basic_pubd.called = 0
		errors['pubd'] = 0
		unchecked['pubd'] = 0
		valids['pubd'] = 0
	basic_pubd.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_pubd.has_key(fkey)):
		if(fields_pubd[fkey] != None):
			error = fields_pubd[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "pubd:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['pubd']    += error
	unchecked['pubd'] += unchk
	valids['pubd']    += (not error)


#------------------------------------------------------------------------
# Handler:	basic_rootd()
#

fields_rootd =	{
			'bpki-ta'		:	chkfile,
			'child-bpki-cert'	:	chkfile,

			'rootd-bpki-cert'	:	chkfile,
			'rootd-bpki-crl'	:	chkfile,
			'rootd-bpki-key'	:	chkkeyfile,

			'rpki-base-uri'		:	chkuri,
			'rpki-class-name'	:	chknonnull,

			'rpki-root-cert'	:	chkfile,
			'rpki-root-cert-uri'	:	chkuri,
			'rpki-root-crl'		:	chkfile,
			'rpki-root-dir'		:	chkdir,
			'rpki-root-key'		:	chkkeyfile,
			'rpki-root-manifest'	:	chkfile,

			'rpki-subject-cert'	:	chkfile,
			'rpki-subject-lifetime'	:	chktime,
			'rpki-subject-pkcs10'	:	chkfile,

			'server-host'		:	chkhostname,
			'server-port'		:	chkhostport,

		}

def basic_rootd(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_rootd, "called")):
		basic_rootd.called = 0
		errors['rootd'] = 0
		unchecked['rootd'] = 0
		valids['rootd'] = 0
	basic_rootd.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_rootd.has_key(fkey)):
		if(fields_rootd[fkey] != None):
			error = fields_rootd[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "rootd:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['rootd']    += error
	unchecked['rootd'] += unchk
	valids['rootd']    += (not error)


#------------------------------------------------------------------------
# Handler:	basic_rpkid()
#

fields_rpkid =	{
			'bpki-ta'		:	chkfile,
			'irbe-cert'		:	chkfile,
			'irdb-cert'		:	chkfile,
			'irdb-url'		:	chkurl,
			'rpkid-cert'		:	chkfile,
			'rpkid-key'		:	chkkeyfile,
			'server-host'		:	chkhostname,
			'server-port'		:	chkhostport,
			'sql-database'		:	chknonnull,
			'sql-password'		:	chksqlpass,
			'sql-username'		:	chksqluser,

		}

def basic_rpkid(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_rpkid, "called")):
		basic_rpkid.called = 0
		errors['rpkid'] = 0
		unchecked['rpkid'] = 0
		valids['rpkid'] = 0
	basic_rpkid.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_rpkid.has_key(fkey)):
		if(fields_rpkid[fkey] != None):
			error = fields_rpkid[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "rpkid:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['rpkid']    += error
	unchecked['rpkid'] += unchk
	valids['rpkid']    += (not error)

#------------------------------------------------------------------------
# Handler:	basic_web_portal()
#
#		This assumes that the user in sql-username is an actual
#		system account name.  This assumption will be investigated
#		to see if the code must be fixed.
#

fields_web_portal = {
			'sql-database'	:	chknonnull,
			'sql-password'	:	chksqlpass,
			'sql-username'	:	chksqluser,
			'secret-key'	:	chksqlpass,
		    }

def basic_web_portal(fkey,fval,trval):
	global errors			# Error counts by config sections.
	global unchecked		# Unchecked-field counts by sections.
	global valids			# Valid-field counts by sections.

	if(not hasattr(basic_web_portal, "called")):
		basic_web_portal.called = 0
		errors['web_portal'] = 0
		unchecked['web_portal'] = 0
		valids['web_portal'] = 0
	basic_web_portal.called += 1

	#
	# Initialize some result values.
	#
	error = 0
	unchk = 0

	if(fields_web_portal.has_key(fkey)):
		if(fields_web_portal[fkey] != None):
			error = fields_web_portal[fkey](trval, fkey)
		else:
			unchk = 1
	else:
		print "web_portal:  specialty checking required for field <%s>" % fkey

	#
	# Add the results to our running totals.
	#
	errors['web_portal']    += error
	unchecked['web_portal'] += unchk
	valids['web_portal']    += (not error)


#------------------------------------------------------------------------
# This dictionary maps config-file sections to handlers for each
# section's fields for basic checks.
#
basic_secthandlers =	{
			'autoconf' :	basic_autoconf,
			'irdbd' :	basic_irdbd,
			'myrpki' :	basic_myrpki,
			'pubd' :	basic_pubd,
			'rootd' :	basic_rootd,
			'rpkid' :	basic_rpkid,
			'web_portal' :	basic_web_portal,
		}


#########################################################################

#------------------------------------------------------------------------
# Routine:	basic_checks()
#
# Purpose:	Run the basic checks on the config file's fields.
#		This is/will be/should be run every time rpkichk is run.
#		This checks for things like missing files, bad permissions
#		on key files, directory not actually a directory, etc.
#
def basic_checks():
	global conffile			# Configuration file.
	global cfg			# Configuration file contents.
	global basic_secthandlers	# Handlers for config file sections.
	global parseerrs		# Collected parsing errors.
	global badsect			# Invalid config section names.

	probcnt = 0			# Count of problems we found.

	#
	# Reset our list of problems.
	#
	getproblems(1)

	#
	# Get the sections in the config file.
	#
	sections = cfg.cfg.sections()

	#
	# Run the validation checks, section by section...
	#
	for sect in sections:

		#
		# ... maybe not this section...
		#
		if(skipsect[sect] != 0): continue

		#
		# ... but *definitely* these fields.
		#
		for (fkey, fval) in cfg.cfg.items(sect):

			#
			# We'll try to get the key's translated value.
			#
			if(basic_secthandlers.has_key(sect)):
				try:
					trval = cfg.get(fkey, section = sect)
				except Exception, evt:
					#
					# The key wasn't recognized, so we'll
					# save its name.
					#
					evtstr = str(evt)
					if(parseerrs.has_key(evtstr)):
						parseerrs[evtstr] += 1
					else:
						parseerrs[evtstr] = 1
						print evtstr
					continue

				#
				# Call the section handler for this
				# particular key and value.
				#
				basic_secthandlers[sect](fkey,fval,trval);
						
			else:
				#
				# The section wasn't recognized, so we'll
				# save its name for later reporting.
				#
				badsect[sect] = 1

		#
		# Squirrel away the problems found in this section.
		#
		problems[sect] = getproblems(1)
		probcnt += len(problems[sect])


	#
	# Return the number of problems we found in the file.
	#
	return(probcnt)


#########################################################################


cross_fields_autoconf =	[
			]

cross_fields_irdbd = [
		'irdbd:server-host',	'myrpki:irdbd_server_host',
		'irdbd:server-port',	'myrpki:irdbd_server_port',
		'irdbd:sql-database',	'myrpki:irdbd_sql_database',
		'irdbd:sql-password',	'myrpki:irdbd_sql_password',
		'irdbd:sql-username',	'myrpki:irdbd_sql_username',
	]

cross_fields_myrpki = [
		'myrpki:irdbd_server_host',		'irdbd:server-host',
		'myrpki:irdbd_server_port',		'irdbd:server-port',
		'myrpki:irdbd_sql_database',		'irdbd:sql-database',
		'myrpki:irdbd_sql_password',		'irdbd:sql-password',
		'myrpki:irdbd_sql_username',		'irdbd:sql-username',
		'myrpki:pubd_server_host',		'pubd:server-host',
		'myrpki:pubd_server_port',		'pubd:server-port',
		'myrpki:pubd_sql_database',		'pubd:sql-database',
		'myrpki:pubd_sql_password',		'pubd:sql-password',
		'myrpki:pubd_sql_username',		'pubd:sql-username',
		'myrpki:publication_base_directory',	'pubd:publication-base',
		'myrpki:rootd_server_host',		'rootd:server-host',
		'myrpki:rootd_server_port',		'rootd:server-port',
		'myrpki:rpkid_server_host',		'rpkid:server-host',
		'myrpki:rpkid_server_port',		'rpkid:server-port',
		'myrpki:rpkid_sql_database',		'rpkid:sql-database',
		'myrpki:rpkid_sql_password',		'rpkid:sql-password',
		'myrpki:rpkid_sql_username',		'rpkid:sql-username',
	]

cross_fields_pubd = [
		'pubd:bpki-ta',		 'rootd:bpki-ta',
		'pubd:bpki-ta',		 'rpkid:bpki-ta',
		'pubd:irbe-cert',	 'rpkid:irbe-cert',
		'pubd:publication-base', 'myrpki:publication_base_directory',
		'pubd:server-host',	 'myrpki:pubd_server_host',
		'pubd:server-port',	 'myrpki:pubd_server_port',
		'pubd:sql-database',	 'myrpki:pubd_sql_database',
		'pubd:sql-password',	 'myrpki:pubd_sql_password',
		'pubd:sql-username',	 'myrpki:pubd_sql_username',
	]

cross_fields_rootd = [
		'rootd:bpki-ta',	'pubd:bpki-ta',
		'rootd:bpki-ta',	'rpkid:bpki-ta',
		'rootd:server-host',	'myrpki:rootd_server_host',
		'rootd:server-port',	'myrpki:rootd_server_port',
	]

cross_fields_rpkid = [
		'rpkid:bpki-ta',	'pubd:bpki-ta',
		'rpkid:bpki-ta',	'rootd:bpki-ta',
		'rpkid:irbe-cert',	'pubd:irbe-cert',
		'rpkid:server-host',	'myrpki:rpkid_server_host',
		'rpkid:server-port',	'myrpki:rpkid_server_port',
		'rpkid:sql-database',	'myrpki:rpkid_sql_database',
		'rpkid:sql-password',	'myrpki:rpkid_sql_password',
		'rpkid:sql-username',	'myrpki:rpkid_sql_username',
	]

cross_fields_web_portal =	[
				]


#------------------------------------------------------------------------
# This dictionary maps config-file sections to lists of the cross-checks
# that must be done for each section.
#
cross_sectfields =	{
			'autoconf'	:	cross_fields_autoconf,
			'irdbd'		:	cross_fields_irdbd,
			'myrpki'	:	cross_fields_myrpki,
			'pubd'		:	cross_fields_pubd,
			'rootd'		:	cross_fields_rootd,
			'rpkid'		:	cross_fields_rpkid,
			'web_portal'	:	cross_fields_web_portal,
		}

def cross_check_sect(cfg,sect):
	global cck_errors	# Cross-check error counts by config sections.
	global cck_unchecked	# Cross-check unchecked-field counts by sects.
	global cck_valids	# Cross-check valid-field counts by sections.

	#
	# Build the label for this cross check.
	#
	label = sect + '_cross'

	#
	# Initialize our error counts.
	#
	cck_errors[label]    = 0
	cck_unchecked[label] = 0
	cck_valids[label]    = 0

	#
	# Get the array to check.
	#
	crossfields = cross_sectfields[sect]

	#
	# Initialize some result values.
	#
	count = 0
	error = 0
	unchk = 0

	#
	# Compare each pair in this section's cross-check array to 
	# see if they're equal.
	#
	for ind in range(0, len(crossfields), 2):

		#
		# Divide the pieces into the local and remote
		# section/field pieces.
		#
		loc = re.split(':', crossfields[ind])
		rmt = re.split(':', crossfields[ind+1])

		#
		# See if we're skipping checks in the local or remote section.
		#
		if((skipsect[loc[0]] != 0) or
		   (skipsect[rmt[0]] != 0)):
			vprint("skipping check of %s:%s to %s:%s", loc[0], loc[1], rmt[0], rmt[1])
			unchk += 1
			continue

		#
		# Compare these values.
		#
		error += compvals(cfg, loc[0], loc[1], rmt[0], rmt[1])
		count += 1

	#
	# Add the results to our running totals.
	#
	cck_errors[label]    += error
	cck_unchecked[label] += unchk
	cck_valids[label]    += (count - error)


#------------------------------------------------------------------------
# Routine:	cross_checks()
#
# Purpose:	Run the cross checks on the config file's fields.
#
def cross_checks():
	global cfg			# Configuration file contents.
	global cross_sectfields		# Comparisons for config file sections.
	global parseerrs		# Collected parsing errors.
	global badsect			# Invalid config section names.

	probcnt = 0			# Count of problems we found.

	#
	# Reset our list of problems.
	#
	getproblems(1)

	#
	# Get the sections in the config file.
	#
	sections = cfg.cfg.sections()

	#
	# Run the validation checks, section by section...
	#
	for sect in sections:

		#
		# We'll try to get the key's translated value.
		#
		if(cross_sectfields.has_key(sect)):

			#
			# ... but *definitely* this section.
			#
			cross_check_sect(cfg,sect)

		else:
			#
			# The section wasn't recognized, so we'll
			# save its name for later reporting.
			#
			badsect[sect] = 1

		#
		# Squirrel away the problems found in this section.
		#
		cck_problems[sect] = getproblems(1)
		probcnt += len(cck_problems[sect])

	#
	# Return the number of problems we found in the file.
	#
	return(probcnt)


#########################################################################

#------------------------------------------------------------------------
# Handler:	recval_chk()
#

#
# The three fields of each line are:
#	simple-comparison flag	(1 - simple comparison; 0 - variable to eval)
#	field to check
#	value to compare to
#
rv_fields = [
	1, 'myrpki:run_rpkid',			'yes',
	1, 'myrpki:irdbd_server_host',		'localhost',
	1, 'myrpki:run_pubd',			'no',
	1, 'myrpki:run_rootd',			'no',
	1, 'myrpki:rootd_server_host',		'localhost',
	1, 'myrpki:publication_rsync_module',	'rpki',
	1, 'myrpki:publication_root_module',	'root',
	1, 'myrpki:shared_sql_username',	'rpki',
	1, 'myrpki:rpkid_sql_database',		'rpkid',
	1, 'myrpki:irdbd_sql_database',		'irdbd',
	1, 'myrpki:pubd_sql_database',		'pubd',

	0, 'myrpki:bpki_servers_directory',	'autoconf:datarootdir/rpki',
	0, 'myrpki:publication_rsync_server',	'myrpki:pubd_server_host',
	0, 'myrpki:start_rpkid',		'myrpki:run_rpkid',
	0, 'myrpki:start_irdbd',		'myrpki:run_rpkid',
	0, 'myrpki:start_pubd',			'myrpki:run_pubd',
	0, 'myrpki:start_rootd',		'myrpki:run_rootd',

    ]

def recval_chk(sect):
	global rv_errors	# Recval-check error counts by config sections.
	global rv_unchecked	# Recval-check unchecked-field counts by sects.
	global rv_valids	# Recval-check valid-field counts by sections.
	global rv_problems	# List of problems found in recval checks.

	if(not hasattr(recval_chk, "called")):
		recval_chk.called = 0
	recval_chk.called += 1

	#
	# Initialize some result values.
	#
	count = 0
	error = 0
	unchk = 0

	#
	# Compare each triplet in this section's recval-check array to 
	# see if they're equal.
	#
	for ind in range(0, len(rv_fields), 3):
		flag = rv_fields[ind]
		val1 = rv_fields[ind+1]
		val2 = rv_fields[ind+2]

		#
		# Divide the field to check into its section/field pieces.
		#
		loc = re.split(':', val1)

		#
		# Skip this group if it isn't in the given section.
		#
		if(loc[0] != sect):
			continue

		#
		# See if we're skipping checks in the comparison field.
		#
		if(skipsect[loc[0]] != 0):
			vprint("skipping check of %s:%s to %s", loc[0], loc[1], val2)
			unchk += 1
			continue

		if(flag == 1):

			#
			# Compare the check field to the related value.
			#
			error += comp1val(cfg, loc[0], loc[1], val2)
			count += 1

		else:

			#
			# Divide the remote field into its section/field pieces.
			#
			rmt = re.split(':', val2)

			#
			# See if we're skipping checks in the remote section.
			#
			if(skipsect[rmt[0]] != 0):
				vprint("skipping check of %s:%s to %s:%s", loc[0], loc[1], rmt[0], rmt[1])
				unchk += 1
				continue

			#
			# Compare these values.
			#
			error += compvals(cfg, loc[0], loc[1], rmt[0], rmt[1])
			count += 1

	#
	# Add the results to our running totals.
	#
	rv_errors[sect]    += error
	rv_unchecked[sect] += unchk
	rv_valids[sect]    += (count - error)

	#
	# Squirrel away the problems found in this section.
	#
	rv_problems[sect] = getproblems(1)


#########################################################################

#------------------------------------------------------------------------
# Routine:	recval_checks()
#
# Purpose:	Run the basic checks on the config file's fields.
#		This is/will be/should be run every time rpkichk is run.
#		This checks for things like missing files, bad permissions
#		on key files, directory not actually a directory, etc.
#
def recval_checks():
	global cfg			# Configuration file contents.

	probcnt = 0			# Count of problems we found.

	#
	# Reset our list of problems.
	#
	getproblems(1)

	#
	# Get the sections in the config file.
	#
	sections = cfg.cfg.sections()

	#
	# Initialize our data aggregations.
	#
	for sect in sections:
		rv_errors[sect] = 0
		rv_unchecked[sect] = 0
		rv_valids[sect] = 0

	#
	# Run the validation checks, section by section...
	#
	for sect in sections:

		recval_chk(sect)

	#
	# Return the number of problems we found in the file.
	#
	return(probcnt)


#########################################################################

#------------------------------------------------------------------------
# Routine:	check_rpki()
#
# Purpose:	Run the validation checks on the config file's fields.
#
def check_rpki():

	#
	# Run the basic checks to ensure the rpki.conf file is at least
	# minimally okay.
	#
	if(dobasic):
		basic_checks()

	#
	# Run the cross checks to dig a bit deeper into the rpki.conf file.
	#
	if(docross):
		cross_checks()

	#
	# Run the recommended-value checks.
	#
	if(dorecval):
		recval_checks()


#########################################################################


#------------------------------------------------------------------------
# Routine:	basic_results()
#
# Purpose:	Give the results of the basic validation checks.
#
def basic_results():

	print ""
	print "Basic Results"

	#
	# Don't print section results if -summary was specified.
	#
	givetable(CHECKS_BASIC)

	#
	# Show the specific problems found in the basic checks.
	#
	giveproblems(CHECKS_BASIC)

	#
	# Summarize the basic validation checks.
	#
	givesummary(CHECKS_BASIC)

	#
	# Print any parsing errors we encountered.
	#
	giveparseerrs()


#------------------------------------------------------------------------
# Routine:	crosscheck_results()
#
# Purpose:	Give the results of the cross-check validation checks.
#
def crosscheck_results():

	print "\n"
	print "Cross-Check Results"

	#
	# Don't print section results if -summary was specified.
	#
	givetable(CHECKS_CROSS)

	#
	# Show the specific problems found in the cross-check checks.
	#
	giveproblems(CHECKS_CROSS)

	#
	# Summarize the cross-check validation checks.
	#
	givesummary(CHECKS_CROSS)

	#
	# Print any parsing errors we encountered.
	#
	giveparseerrs()


#------------------------------------------------------------------------
# Routine:	recval_results()
#
# Purpose:	Give the results of the recommended-value validation checks.
#
def recval_results():

	print "\n"
	print "Recommended-Value Results"

	#
	# Don't print section results if -summary was specified.
	#
	givetable(CHECKS_RECVAL)

	#
	# Show the specific problems found in the recommended-value checks.
	#
	giveproblems(CHECKS_RECVAL)

	#
	# Summarize the recommended-value validation checks.
	#
	givesummary(CHECKS_RECVAL)

	#
	# Print any parsing errors we encountered.
	#
	giveparseerrs()


#------------------------------------------------------------------------
# Routine:	results()
#
# Purpose:	Give the results of the validation checks.
#
def results():

	if(dobasic):
		basic_results()

	if(docross):
		crosscheck_results()

	if(dorecval):
		recval_results()


#------------------------------------------------------------------------
# Routine:	giveproblems()
#
# Purpose:	Show the problems found in each section.
#
def giveproblems(chktype):
	probcnt = 0			# Count of problems we're reporting.

	#
	# Don't do anything here if we aren't supposed to show problems.
	#
	if(showprobs == 0):
		return

	#
	# Select the problem list.  If an invalid check type was specified,
	# then we'll manufacture a new problem to report.
	#
	if(chktype == CHECKS_BASIC):
		problist = problems
	elif(chktype == CHECKS_CROSS):
		problist = cck_problems
	elif(chktype == CHECKS_RECVAL):
		problist = rv_problems
	else:
		problist = list()
		list[0] = "unknown check type - ", chktype

	#
	# Give a short message and return if we didn't find any problems.
	#
	if((len(problist) == 0) and (verbose == 0)):
		print "no problems found\n"
		return

	for sect in sorted(problist):
		maxlen = -1			# Maximum section-name length.

		probarr = problist[sect]

		probs = len(probarr)
		probcnt += probs

		#
		# If this section had no problems, go to the next section.
		# If we're verbose, give a nice informational message first.
		#
		if(probs == 0):
			if(verbose):
				print "%s section:  no problems\n" % sect

			continue

		#
		# Get the longest field name.
		#
		for prob in sorted(probarr):
			pieces = re.split(':', prob)
			if(len(pieces[0]) > maxlen):	maxlen = len(pieces[0])
		maxlen += 1

		#
		# Print the section name and the problems in the section.
		#
		print "problems in %s section:" % sect
		for prob in probarr:
			pieces = re.split(':[ \t]*', prob)
			pieces[0] += ':'
			print "%-*s  %s" % (maxlen, pieces[0], pieces[1])

		print ""

	#
	# Give a short message if we didn't find any problems.
	# Maybe give a problem count if there were problems.
	#
	if(probcnt == 0):
		print "no problems found\n"
	elif(verbose):
		print "problems found:  %d\n" % probcnt


#------------------------------------------------------------------------
# Routine:	givesummary()
#
# Purpose:	Give a summary of the validation checks results.
#
def givesummary(chktype):

	totalerrs = 0			# Total count of errors found.
	totalunchks = 0			# Total count of unchecked fields.
	totalvalids = 0			# Total count of valid fields found.

	if(showsummary == 0):
		return

	if(chktype == CHECKS_BASIC):

		#
		# Calculate the totals we'll be reporting.
		#
		for key in errors.keys():	totalerrs += errors[key]
		for key in unchecked.keys():	totalunchks += unchecked[key]
		for key in valids.keys():	totalvalids += valids[key]

		print "summary of basic results:"
		print "\ttotal valid fields (basic checks):  %d" % totalvalids
		print "\ttotal errors:  %d" % totalerrs
		print "\ttotal unchecked fields:  %d" % totalunchks

	elif(chktype == CHECKS_CROSS):

		#
		# Calculate the totals we'll be reporting.
		#
		for key in cck_errors.keys():		totalerrs   += cck_errors[key]
		for key in cck_unchecked.keys():	totalunchks += cck_unchecked[key]
		for key in cck_valids.keys():		totalvalids += cck_valids[key]

		print "total valid fields (cross checks):  %d" % totalvalids
		print "total errors:  %d" % totalerrs
		print "total unchecked fields:  %d" % totalunchks

	elif(chktype == CHECKS_RECVAL):

		#
		# Calculate the totals we'll be reporting.
		#
		for key in rv_errors.keys():	totalerrs   += rv_errors[key]
		for key in rv_unchecked.keys():	totalunchks += rv_unchecked[key]
		for key in rv_valids.keys():	totalvalids += rv_valids[key]

		print "total valid fields (recommended-value checks):  %d" % totalvalids
		print "total errors:  %d" % totalerrs
		print "total unchecked fields:  %d" % totalunchks


#------------------------------------------------------------------------
# Routine:	givetable()
#
# Purpose:	Give the results in tabular form.
#
#		This is a preliminary form.  This will undoubtedly
#		improve over time.
#
def givetable(chktype):
	maxlen = -1			# Maximum section-name length.
	old_format = 0			# Flag for using old output format.

	if(showtable == 0):
		return

	if(chktype == CHECKS_BASIC):

		#
		# Get the longest key name.
		#
		for key in sorted(valids):
			if(len(key) > maxlen):	maxlen = len(key)

		#
		# Bump the longest key length a shade and print the
		# column headers.
		#
		print "%-*s%12s\t%12s\t%12s" % (maxlen, 'Section', 'Valid', 'Errors', 'Unchecked')

		#
		# Print the results for each section we checked.
		#
		for key in sorted(valids):
			print "%-*s%12d\t%12d\t%12d" % (maxlen, key,
								valids[key],
								errors[key],
								unchecked[key])

		print ""

	elif(chktype == CHECKS_CROSS):

		labsect = {}

		#
		# Get the longest key name.
		#
		for key in sorted(cck_valids):
			newkey = re.sub('_cross', '', key)
			if(len(newkey) > maxlen): maxlen = len(newkey)
			labsect[key] = newkey

		#
		# Bump the longest key length a shade and print the
		# column headers.
		#
		print "%-*s%12s\t%12s\t%12s" % (maxlen, 'Section', 'Valid', 'Errors', 'Unchecked')

		#
		# Print the results for each section we checked.
		#
		for key in sorted(cck_valids):
			print "%-*s%12d\t%12d\t%12d" % (maxlen, labsect[key],
							cck_valids[key],
							cck_errors[key],
							cck_unchecked[key])

		print ""

	elif(chktype == CHECKS_RECVAL):

		labsect = {}

		#
		# Get the longest key name.
		#
		for key in sorted(rv_valids):
			newkey = re.sub('_recval', '', key)
			if(len(newkey) > maxlen): maxlen = len(newkey)
			labsect[key] = newkey

		#
		# Bump the longest key length a shade and print the
		# column headers.
		#
		print "%-*s%12s\t%12s\t%12s" % (maxlen, 'Section', 'Valid', 'Errors', 'Unchecked')

		#
		# Print the results for each section we checked.
		#
		for key in sorted(rv_valids):
			print "%-*s%12d\t%12d\t%12d" % (maxlen, labsect[key],
							rv_valids[key],
							rv_errors[key],
							rv_unchecked[key])

		print ""


#------------------------------------------------------------------------
# Routine:	giveparseerrs()
#
# Purpose:	Print the parsing problems encountered.
#
def giveparseerrs():

	#
	# Report bad section keys .
	#
	if(len(parseerrs) > 0):
		print ""
		for evt in parseerrs.keys():
			print "config parse error:  %s" % evt
			print "\tentries affected:  %d" % parseerrs[evt]
			print ""

	#
	# Report bad section names.
	#
	nbs = len(badsect)
	if(nbs > 0):
		print ""
		if(nbs > 1):
			print "%d invalid sections:" % nbs
		else:
			print "1 invalid section:"

		for key in badsect.keys():
			print "\t\"%s\"" % key


#----------------------------------------------------------------------
# Routine:	version()
#
# Purpose:	Print the version number(s) and exit.
#
def version():
	print(VERS)
	exit(0)


#----------------------------------------------------------------------
# Routine:	usage()
#
# Purpose:	Do something with the usage message.
#
#		If the prtflag parameter is non-zero, we'll print and exit.
#		If it is zero, we'll just return the string.
#
def usage(prtflag):

	#
	# Set up our usage string.
	#
	outstr = """usage:  rpkichk [options] <command arguments>

        where [options] are:
                -config conffile        specify configuration file to validate

                -list                   list configuration-section information
                -names                  list configuration-section names;
                                        must be used with -list
                -section section-name   specify section to examine;
                                        must be used with -list
		-summary		give summary of checks only
		-untranslate		-llist gives untranslated values

		-basic			only run basic checks
		-cross			only run cross-checks
		-recval			only run recommended-value checks

                -noautoconf             don't check the autoconf section
                -noirdbd                don't check the irdbd section
                -nomyrpki               don't check the myrpki section
                -nopubd                 don't check the pubd section
                -norootd                don't check the rootd section
                -norpkid                don't check the rpkid section
                -noweb_portal           don't check the web_portal section

                -verbose                give verbose output
                -Version                show version and exit
                -help                   show usage message and exit
                -manpage                show manual page and exit
 """

	#
	# Just return the output if we aren't to print the usage string.
	#
	if(prtflag == 0):
		return(outstr)

	#
	# Print the usage string and exit.
	#
	print(outstr.rstrip())
	exit(0)

#------------------------------------------------------------------------


manpage_info = '''

NAME

rpkichk - validates the contents of an rpki.conf file

SYNOPSIS

  rpkichk [options]

DESCRIPTION

rpkichk validates the contents of an rpki.conf file.  The configuration
file is validated to ensure that reasonable values are specified for the
various fields.

Some fields are not able to be fully validated.  For example, the
"server-host" field can be checked to ensure that it contains only
characters valid for a hostname, but it cannot be checked to ensure
that the specified hostname is truly the name of the required server
host.

The default configuration file is /etc/rpki.conf.  The -config option
allows the user to specify an alternate file to be validated.

The entire file is checked by default.  However, there are options that
restrict certain configuration sections from being checked.  For example,
the -nopubd option prevents validation of the fields in the pubd section.  

CHECK TYPES

rpkichk performs three types of checks -- basic checks, cross-checks, and
recommended-value checks.  All types of checks are performed by default.
The -basic, -cross, and -recval options allow only a subset of checks to
be performed.

Basic checks are rudimentary checks of the configuration values in an
rpki.conf file.  For example, it checks that a database name isn't null,
not that the database exists; or that a key file exists and is only
readable by the file's owner, not that the key contents are a valid key.

Cross-checks ensure that an rpki.conf file is internally consistent.  There
are a number of fields in the configuration file that are related and are
expected to have the same values.  For example, the rootd section has the
server-port and the myrpki section has the rootd_server_port field.  The
cross-checks ensure that these fields are the same.

Recommended-value checks ensure that certain fields in an rpki.conf file 
have the values recommended by the developers of the rpki.net software.

RESULT REPORTING

rpkichk provides three types of output:  a problem report, a table of
results, and a summary.  All three are given by default.  However, any
combination of the three may be selected by using the -problems, -table,
and -summary options.

In addition to validating the contents of an rpki.conf file, rpkichk can
display the contents.  The -list option will display fields and values in
the rpki.conf file, but no validation will be performed.  With no other
options, all fields in all sections of the file will be listed.  The -names
option lists just the sections of the rpki.conf file.  The -section option
lists only the fields in the named section.  Normally, field listings give
the value as used by the RPKI software.  However, the -untranslate option
will give the value exactly as it is given in the rpki.conf file.

OPTIONS

rpkichk takes the following options:
        -config conffile         specify configuration file to validate
        -list                    list configuration-section information
        -names                   list configuration-section names;
                                 must be used in conjunction with -list
        -untranslate             display untranslated values from the
				 configuration file
                                 must be used in conjunction with -list
        -section section-name    specify section to examine;
                                 must be used in conjunction with -list

        -basic                   only run basic checks
        -cross                   only run cross-checks
        -recval                  only run recommended-value checks

	-problems		 only show problems found
        -summary                 give summary of checks only
	-table			 provide results in tabular form

        -noautoconf              don't check the autoconf section
        -noirdbd                 don't check the irdbd section
        -nomyrpki                don't check the myrpki section
        -nopubd                  don't check the pubd section
        -norootd                 don't check the rootd section
        -norpkid                 don't check the rpkid section
        -noweb_portal            don't check the web_portal section

        -verbose                 give verbose output
        -Version                 show version and exit
        -help                    show usage message and exit
        -manpage                 show the manual page and exit

COPYRIGHT

Copyright 2015 PARSONS, Inc.  All rights reserved.

AUTHOR

Wayne Morrison, tewok@tislabs.com

SEE ALSO

"RSI-EARS Step-By-Step Guide: Validation Checks Performed for rpki.conf Files"

'''


#----------------------------------------------------------------------
# Routine:	manpage()
#
# Purpose:	Print the internal manual page and exit.
#
def manpage():
	print(manpage_info)
	exit(0)


#------------------------------------------------------------------------

#
# Do everything.
#
main()
exit(0)

